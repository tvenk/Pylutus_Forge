import json
from compiler.ast_parser import PylutusParser
from compiler.type_checker import TypeChecker
from compiler.semantic_validator import SemanticValidator
from compiler.ir import IRTransformer

def load_key_map(file_path):
    with open(file_path, 'r') as f:
        return json.load(f)

def generate_haskell_code(ir, key_map):
    lines = [
        "-- Auto-generated by Pylutus Forge",
        "{-# INLINABLE mkValidator #-}",
        "import PlutusTx.Prelude",
        "import Plutus.V1.Ledger.Api"
    ]

    if ir.value["args"] == ["ctx"]:
        lines.append("mkValidator :: ScriptContext -> Bool")
        lines.append("mkValidator ctx =")
    else:
        lines.append("mkValidator :: Datum -> Redeemer -> ScriptContext -> Bool")
        lines.append("mkValidator datum redeemer ctx =")

    def generate_condition(node):
        if node.node_type == "And":
            return " && ".join(generate_condition(child) for child in node.children)
        elif node.node_type == "DatumCheck":
            return f"datum == \"{node.value}\""
        elif node.node_type == "RedeemerCheck":
            return f"redeemer == \"{node.value}\""
        elif node.node_type == "SigCheck":
            pkh = key_map.get("pylutus_sig", {}).get("pubkeyhash", "PubKeyHash") + f" \"{node.value}\""
            return f"txSignedBy ctx {pkh}"
        elif node.node_type == "Compare":
            left = generate_condition(node.children[0])
            right = generate_condition(node.children[1])
            op = "==" if node.value == "Eq" else node.value.lower()
            return f"{left} {op} {right}"
        return "False"

    def generate_statement(node):
        if node.node_type == "Return":
            value = node.children[0]
            if value.node_type == "Bool":
                return f"traceIfFalse \"Return\" {str(value.value).capitalize()}"
            elif value.node_type == "SigCheck":
                pkh = key_map.get("pylutus_sig", {}).get("pubkeyhash", "PubKeyHash") + f" \"{value.value}\""
                return f"traceIfFalse \"Signature check\" (txSignedBy ctx {pkh})"
            return "traceIfFalse \"Invalid return\" False"
        elif node.node_type == "Pay":
            pkh = key_map.get("pylutus_pay", {}).get("pubkeyhash", "PubKeyHash") + f" \"{node.value['addr']}\""
            amount = node.value["amount"]
            return f"traceIfFalse \"Payment failed\" (checkPayment ctx {pkh} {amount})"
        elif node.node_type == "SigCheck":
            pkh = key_map.get("pylutus_sig", {}).get("pubkeyhash", "PubKeyHash") + f" \"{node.value}\""
            return f"traceIfFalse \"Signature check\" (txSignedBy ctx {pkh})"
        return "traceIfFalse \"Invalid\" False"

    def generate_body(node, indent=1):
        prefix = "    " * indent
        
        if node.node_type == "If":
            condition = generate_condition(node.children[0])
            result = [f"{prefix}if {condition} then ("]
            
            # Process then branch
            then_statements = []
            else_statements = []
            in_else = False
            
            for child in node.children[1:]:
                if child.node_type == "Return" and child.children[0].node_type == "Bool" and not child.children[0].value:
                    in_else = True
                    continue
                
                if not in_else:
                    if child.node_type in ["Pay", "Return", "SigCheck"]:
                        then_statements.append(generate_statement(child))
                else:
                    if child.node_type in ["Pay", "Return", "SigCheck"]:
                        else_statements.append(generate_statement(child))
            
            # Add then statements
            for stmt in then_statements:
                result.append(f"{prefix}    {stmt}")
            
            # Add return/valid for then branch
            has_then_return = any("Return" in stmt for stmt in then_statements)
            if not has_then_return:
                result.append(f"{prefix}    traceIfFalse \"Return\" True")
            result.append(f"{prefix}    traceIfFalse \"Valid\" True")
            
            # Add else branch
            result.append(f"{prefix}) else (")
            if else_statements:
                for stmt in else_statements:
                    result.append(f"{prefix}    {stmt}")
                has_else_return = any("Return" in stmt for stmt in else_statements)
                if not has_else_return:
                    result.append(f"{prefix}    traceIfFalse \"Return\" True")
                result.append(f"{prefix}    traceIfFalse \"Valid\" True")
            else:
                result.append(f"{prefix}    traceIfFalse \"Invalid\" False")
            
            result.append(f"{prefix})")
            return result
        else:
            # Handle non-If nodes
            statements = []
            has_return = False
            
            for child in node.children:
                if child.node_type in ["Pay", "SigCheck"]:
                    statements.append(generate_statement(child))
                elif child.node_type == "Return":
                    stmt = generate_statement(child)
                    statements.append(stmt)
                    if "Return" in stmt:
                        has_return = True
                elif child.node_type == "If":
                    statements.extend(generate_body(child, indent))
                    return statements  # If node handles its own return/valid
            
            result = []
            for stmt in statements:
                result.append(f"{prefix}{stmt}")
            
            if not has_return:
                result.append(f"{prefix}traceIfFalse \"Return\" True")
            result.append(f"{prefix}traceIfFalse \"Valid\" True")
            
            return result

    body_lines = generate_body(ir)
    lines.extend(body_lines)

    # Add checkPayment function if needed
    if any("checkPayment" in line for line in body_lines):
        lines.extend([
            "",
            "checkPayment :: ScriptContext -> PubKeyHash -> Integer -> Bool",
            "checkPayment ctx pkh amount =",
            "    any (\\o -> txOutValue o == lovelaceValueOf amount && txOutAddress o == pubKeyHashAddress pkh) (txInfoOutputs $ scriptContextTxInfo ctx)"
        ])

    return "\n".join(lines)

def main():
    import sys
    if len(sys.argv) != 2:
        print("Usage: python3 pylutus_forge.py <contract_file>")
        return

    file_path = sys.argv[1]
    with open(file_path, 'r') as f:
        source = f.read()

    parser = PylutusParser()
    ast = parser.parse(source)
    if parser.errors:
        print("Parse errors:")
        for error in parser.errors:
            print(error)
        return

    type_checker = TypeChecker()
    type_checker.check(ast)
    if type_checker.errors:
        print("Type errors:")
        for error in type_checker.errors:
            print(error)
        return

    semantic_validator = SemanticValidator()
    semantic_validator.validate(ast)
    if semantic_validator.errors:
        print("Semantic errors:")
        for error in semantic_validator.errors:
            print(error)
        return

    transformer = IRTransformer()
    ir = transformer.transform(ast)
    if transformer.errors:
        print("IR transformation errors:")
        for error in transformer.errors:
            print(error)
        return

    key_map = load_key_map("pylutus_key.json")
    haskell_code = generate_haskell_code(ir.children[0], key_map)

    print(haskell_code)
    with open("output_contract.hs", "w") as f:
        f.write(haskell_code)
    print("Compiled to output_contract.hs")

if __name__ == "__main__":
    main()
