import sys
import json
from compiler.ast_parser import PylutusParser
from compiler.type_checker import TypeChecker
from compiler.semantic_validator import SemanticValidator

def load_key_map(path='pylutus_key.json'):
    with open(path) as f:
        return json.load(f)

def generate_haskell_code(ast, key_map):
    haskell_lines = []
    haskell_lines.append('-- Auto-generated by Pylutus Forge')
    haskell_lines.append('{-# INLINABLE mkValidator #-}')
    haskell_lines.append('import PlutusTx.Prelude')
    haskell_lines.append('import Plutus.V1.Ledger.Api')
    haskell_lines.append('mkValidator :: ScriptContext -> Bool')
    haskell_lines.append('mkValidator ctx =')

    indent = '    '

    def generate_node(node, depth=1):
        indent_str = indent * depth
        if node.node_type == "Module":
            for child in node.children:
                generate_node(child, depth)

        elif node.node_type == "FunctionDef":
            body_lines = []
            for child in node.children:
                child_lines = generate_node(child, depth)
                if child_lines:
                    body_lines.extend(child_lines)
            if len(body_lines) == 1 and child_lines[0].startswith('if '):  # Single if statement
                haskell_lines.append(f"{indent}{body_lines[0]}")
            elif body_lines:
                haskell_lines.append(f"{indent}({' && '.join(body_lines)})")
            else:
                haskell_lines.append(f"{indent}True")

        elif node.node_type == "If":
            test = node.children[0]
            body = node.children[1:len(node.children)//2 + 1]
            orelse = node.children[len(node.children)//2 + 1:]
            condition = generate_condition(test)
            then_lines = []
            else_lines = []
            for child in body:
                child_lines = generate_node(child, depth + 1)
                if child_lines:
                    then_lines.extend(child_lines)
            for child in orelse:
                child_lines = generate_node(child, depth + 1)
                if child_lines:
                    else_lines.extend(child_lines)
            then_body = ' && '.join(then_lines) if then_lines else 'True'
            else_body = ' && '.join(else_lines) if else_lines else 'False'
            return [f"if {condition} then traceIfFalse \"Valid\" ({then_body}) else traceIfFalse \"Invalid\" ({else_body})"]

        elif node.node_type == "Return":
            value = generate_condition(node.children[0])
            if value == "False":
                return [value]  # Direct False for return False
            return [f"traceIfFalse \"Return\" {value}"]

        elif node.node_type == "PylutusPay":
            addr = node.value["addr"]
            amount = node.value["amount"]
            return [f"traceIfFalse \"Payment failed\" (checkPayment ctx (PubKeyHash \"{addr}\") {amount})"]

        return []

    def generate_condition(node):
        if node.node_type == "Bool":
            return str(node.value).capitalize()
        elif node.node_type == "PylutusSig":
            return f'txSignedBy ctx (PubKeyHash "{node.value}")'
        elif node.node_type == "Compare":
            left = generate_condition(node.children[0])
            right = generate_condition(node.children[1])
            op = node.value
            return f"{left} {op} {right}"
        elif node.node_type == "Name":
            return key_map.get(node.value, node.value)
        return ""

    # Generate validator body
    generate_node(ast)

    # Add payment check helper function
    haskell_lines.append('checkPayment :: ScriptContext -> PubKeyHash -> Integer -> Bool')
    haskell_lines.append('checkPayment ctx pkh amount =')
    haskell_lines.append('    any (\\o -> txOutValue o == lovelaceValueOf amount && txOutAddress o == pubKeyHashAddress pkh) (txInfoOutputs $ scriptContextTxInfo ctx)')

    return '\n'.join(haskell_lines)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python3 pylutus_forge.py <input_file.pylutus>")
        sys.exit(1)

    input_filename = sys.argv[1]
    with open(input_filename, 'r') as f:
        source = f.read()

    # Step 1: Parse
    parser = PylutusParser()
    ast = parser.parse(source)
    if parser.errors:
        print("Parsing errors:")
        for error in parser.errors:
            print(error)
        sys.exit(1)

    # Step 2: Type Check
    type_checker = TypeChecker()
    if not type_checker.check(ast):
        print("Type errors:")
        for error in type_checker.errors:
            print(error)
        sys.exit(1)

    # Step 3: Semantic Validation
    semantic_validator = SemanticValidator()
    if not semantic_validator.validate(ast):
        print("Semantic errors:")
        for error in semantic_validator.errors:
            print(error)
        sys.exit(1)

    # Step 4: Compile
    key_map = load_key_map()
    haskell_code = generate_haskell_code(ast, key_map)
    with open('output_contract.hs', 'w') as f:
        f.write(haskell_code)

    print("Compiled to output_contract.hs")
