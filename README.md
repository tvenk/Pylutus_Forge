# Pylutus Forge

**Pylutus Forge** is a Python-to-Plutus compiler designed to enable developers to write Cardano smart contracts using Python-like syntax. These contracts are compiled into Plutus (Haskell) code suitable for on-chain deployment on the Cardano blockchain.

---

## ğŸ“ Directory Structure

```bash
pylutus_forge/
â”œâ”€â”€ compiler/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ ast_parser.py
â”‚   â”œâ”€â”€ type_checker.py
â”‚   â”œâ”€â”€ semantic_validator.py
â”‚   â””â”€â”€ utils.py
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ easy_contract.pylutus
â”‚   â”œâ”€â”€ payment_contract.pylutus
â”‚   â”œâ”€â”€ complex_contract.pylutus
â”‚   â”œâ”€â”€ invalid_contract.pylutus
â”‚   â”œâ”€â”€ unreachable_contract.pylutus
â”‚   â””â”€â”€ invalid_payment.pylutus
â”œâ”€â”€ pylutus_forge.py
â”œâ”€â”€ pylutus_key.json
â”œâ”€â”€ output_contract.hs
â”œâ”€â”€ test_ast_parser_updated.py
â”œâ”€â”€ test_semantic_validator.py
â”œâ”€â”€ test_symbol_table.py
â”œâ”€â”€ test_type_checker.py
â”œâ”€â”€ test_utils.py
â”œâ”€â”€ LICENSE
â””â”€â”€ README.md
```

---

## ğŸš€ Overview

Pylutus Forge lowers the barrier to entry for Cardano dApp developers by allowing them to write smart contracts in a clean, Pythonic domain-specific language (DSL) called **Pylutus**.

The tool compiles `.pylutus` files into valid Plutus scripts using the following pipeline:

* **Parser**: Processes `.pylutus` files, stripping comments and parsing Python-like syntax (`if/else`, `return`, etc.).
* **Type Checker**: Ensures type safety (e.g., `ctx: ScriptContext`, `bool` returns).
* **Semantic Validator**: Detects invalid or non-deterministic logic (e.g., unreachable code).
* **Macro Engine**: Replaces custom Pylutus functions like `pylutus_sig(...)` and `pylutus_pay(...)` using `pylutus_key.json`.
* **Code Generator**: Outputs clean Haskell code with `PlutusTx` support and proper smart contract structure.
* **Validator Compiler**: Generates validators for signature and payment conditions with `mkValidator`.

---

## âœ… Phase 1 â€” Core Compiler (Complete)

* ğŸ” **Parser**: Python-like syntax support (`def`, `if`, `return`).
* ğŸ”§ **Macro Expansion**: Converts custom commands into valid Plutus primitives.
* âš™ï¸ **Haskell Code Generation**: Uses `traceIfFalse`, `mkValidator`, and correct PlutusTx types.
* ğŸ” **Validator Logic**: Supports signature validation with `pylutus_sig`.
* ğŸ“„ **Output**: Writes `output_contract.hs`, ready for on-chain deployment.

---

## âœ… Phase 2 â€” Type System & Validation (Complete)

* ğŸ§  **Static Type Checker**: Ensures `ctx: ScriptContext` and `bool` return types, catching errors like `return 42`.
* ğŸ” **Semantic Validator**: Detects unreachable code (e.g., `if True`) and invalid payment amounts (< 1 ADA).
* ğŸ§¾ **Symbol Table**: Tracks variable types and scopes for robust validation.
* ğŸ› ï¸ **Enhanced CLI**: `pylutus_forge.py` orchestrates parsing, type checking, semantic validation, and compilation with clear error reporting.
* ğŸ’¸ **Payment Logic**: Implements `pylutus_pay` for transaction output validations (e.g., payments to specific addresses).

---

### âœ… Example Usage

**Source** (`tests/complex_contract.pylutus`):

```python
def validator(ctx: ScriptContext) -> bool:
    if pylutus_sig("abc123"):
        pylutus_pay("def456", 2000000)
        return True
    else:
        return False
```

**Compile**:

```bash
python3 pylutus_forge.py tests/complex_contract.pylutus
```

**Output** (`output_contract.hs`):

```haskell
-- Auto-generated by Pylutus Forge
{-# INLINABLE mkValidator #-}
import PlutusTx.Prelude
import Plutus.V1.Ledger.Api

mkValidator :: ScriptContext -> Bool
mkValidator ctx =
    if txSignedBy ctx (PubKeyHash "abc123") then
        traceIfFalse "Valid" (
            traceIfFalse "Payment failed" (checkPayment ctx (PubKeyHash "def456") 2000000)
            && traceIfFalse "Return" True
        )
    else
        traceIfFalse "Invalid" False

checkPayment :: ScriptContext -> PubKeyHash -> Integer -> Bool
checkPayment ctx pkh amount =
    any (\o -> txOutValue o == lovelaceValueOf amount && txOutAddress o == pubKeyHashAddress pkh)
        (txInfoOutputs $ scriptContextTxInfo ctx)
```

This generates a Plutus validator that checks for a signature from `abc123` and a payment of 2 ADA to `def456`.

---

## ğŸš§ Phase 3 â€” Future Roadmap

* ğŸ§± **Intermediate Representation (IR)**: Robust Haskell code generation via a typed IR layer.
* ğŸ”„ **Full PlutusTx Type Mapping**: Better handling of Plutus types for complex contracts.
* ğŸ§° **Code Templates**: Include ready-made templates for validators, scripts, redeemers, etc.
* ğŸ§  **IDE Tooling**: VS Code plugin with syntax highlighting, hints, and code completion.

---

## ğŸ“¦ How to Use

Write your smart contract in the `tests/` folder using `.pylutus` syntax.

Example contract (`tests/payment_contract.pylutus`):

```python
def validator(ctx: ScriptContext) -> bool:
    pylutus_pay("abc123", 2000000)
    return True
```

Compile it:

```bash
python3 pylutus_forge.py tests/payment_contract.pylutus
```

Output will be generated in:

```bash
output_contract.hs
```

Test the compiler with provided test scripts:

```bash
python3 test_symbol_table.py
python3 test_ast_parser_updated.py
python3 test_type_checker.py
python3 test_semantic_validator.py
python3 test_utils.py
```

Deploy using Cardano tooling.

---

## ğŸ“ License

This project is open-source and available under the MIT License.

---

## ğŸ“¬ Contact

**Author**: tvenk
**GitHub**: [tvenk](https://github.com/tvenk)
**LinkedIn**: [tbnv](https://www.linkedin.com/in/tbnv)

---
