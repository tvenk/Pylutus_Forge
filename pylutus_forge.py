import json
from compiler.ast_parser import PylutusParser
from compiler.type_checker import TypeChecker
from compiler.semantic_validator import SemanticValidator
from compiler.ir import IRTransformer

def load_key_map(file_path):
    with open(file_path, 'r') as f:
        return json.load(f)

def generate_haskell_code(ir, key_map):
    lines = [
        "-- Auto-generated by Pylutus Forge",
        "{-# INLINABLE mkValidator #-}",
        "import PlutusTx.Prelude",
        "import Plutus.V1.Ledger.Api"
    ]

    if ir.value["args"] == ["ctx"]:
        lines.append("mkValidator :: ScriptContext -> Bool")
        lines.append("mkValidator ctx =")
    else:
        lines.append("mkValidator :: Datum -> Redeemer -> ScriptContext -> Bool")
        lines.append("mkValidator datum redeemer ctx =")

    def generate_condition(node):
        if node.node_type == "And":
            return " && ".join(generate_condition(child) for child in node.children)
        elif node.node_type == "DatumCheck":
            return f"datum == \"{node.value}\""
        elif node.node_type == "RedeemerCheck":
            return f"redeemer == \"{node.value}\""
        elif node.node_type == "SigCheck":
            pkh = key_map.get("pylutus_sig", {}).get("pubkeyhash", "PubKeyHash") + f" \"{node.value}\""
            return f"txSignedBy ctx {pkh}"
        elif node.node_type == "Compare":
            left = generate_condition(node.children[0])
            right = generate_condition(node.children[1])
            op = "==" if node.value == "Eq" else node.value.lower()
            return f"{left} {op} {right}"
        elif node.node_type == "Name":
            return node.value
        return "False"

    def generate_statement(node):
        if node.node_type == "Return":
            value = node.children[0]
            if value.node_type == "Bool":
                return f"traceIfFalse \"Return\" {str(value.value).capitalize()}"
            elif value.node_type == "SigCheck":
                pkh = key_map.get("pylutus_sig", {}).get("pubkeyhash", "PubKeyHash") + f" \"{value.value}\""
                return f"traceIfFalse \"Signature check\" (txSignedBy ctx {pkh})"
            return f"traceIfFalse \"Invalid return\" False"
        elif node.node_type == "Pay":
            pkh = key_map.get("pylutus_pay", {}).get("pubkeyhash", "PubKeyHash") + f" \"{node.value['addr']}\""
            amount = node.value["amount"]
            return f"traceIfFalse \"Payment failed\" (checkPayment ctx {pkh} {amount})"
        elif node.node_type == "SigCheck":
            pkh = key_map.get("pylutus_sig", {}).get("pubkeyhash", "PubKeyHash") + f" \"{node.value}\""
            return f"traceIfFalse \"Signature check\" (txSignedBy ctx {pkh})"
        return f"traceIfFalse \"Invalid\" False"

    def generate_body(node, indent=4):
        prefix = " " * indent
        print(f"DEBUG: Processing node {node.node_type} with children {[c.node_type for c in node.children]}")
        if node.node_type == "If":
            test_code = generate_condition(node.children[0])
            then_nodes = node.children[1:len(node.children)//2 + 1]
            result = [f"{prefix}if {test_code} then ("]
            then_statements = []
            has_return = False
            for child in then_nodes:
                print(f"DEBUG: Processing then child {child.node_type}")
                if child.node_type == "Return":
                    then_statements.append(f"{prefix}    {generate_statement(child)}")
                    has_return = True
                elif child.node_type == "Pay":
                    then_statements.append(f"{prefix}    {generate_statement(child)}")
                elif child.node_type == "SigCheck":
                    then_statements.append(f"{prefix}    {generate_statement(child)}")
            if then_statements:
                result.extend([f"{stmt} &&" for stmt in then_statements])
                if not has_return:
                    result.append(f"{prefix}    traceIfFalse \"Return\" True &&")
                result.append(f"{prefix}    traceIfFalse \"Valid\" True")
            else:
                result.append(f"{prefix}    traceIfFalse \"Valid\" True")
            result.append(f"{prefix}) else (")
            result.append(f"{prefix}    traceIfFalse \"Invalid\" False")
            result.append(f"{prefix})")
            return result
        else:
            statements = []
            has_return = False
            for child in node.children:
                print(f"DEBUG: Processing child {child.node_type}")
                if child.node_type in ["Pay", "SigCheck"]:
                    statements.append(f"{prefix}{generate_statement(child)}")
                elif child.node_type == "Return":
                    statements.append(f"{prefix}{generate_statement(child)}")
                    has_return = True
            if statements:
                result = [f"{stmt} &&" for stmt in statements]
                if not has_return:
                    result.append(f"{prefix}traceIfFalse \"Return\" True &&")
                result.append(f"{prefix}traceIfFalse \"Valid\" True")
                return result
            return [f"{prefix}traceIfFalse \"Valid\" True"]

    body_lines = generate_body(ir)
    lines.extend(body_lines)

    lines.extend([
        "",
        "checkPayment :: ScriptContext -> PubKeyHash -> Integer -> Bool",
        "checkPayment ctx pkh amount =",
        "    any (\\o -> txOutValue o == lovelaceValueOf amount && txOutAddress o == pubKeyHashAddress pkh) (txInfoOutputs $ scriptContextTxInfo ctx)"
    ])

    return "\n".join(lines)

def main():
    import sys
    if len(sys.argv) != 2:
        print("Usage: python3 pylutus_forge.py <contract_file>")
        return

    file_path = sys.argv[1]
    with open(file_path, 'r') as f:
        source = f.read()

    parser = PylutusParser()
    ast = parser.parse(source)
    if parser.errors:
        print("Parse errors:")
        for error in parser.errors:
            print(error)
        return

    type_checker = TypeChecker()
    type_checker.check(ast)
    if type_checker.errors:
        print("Type errors:")
        for error in type_checker.errors:
            print(error)
        return

    semantic_validator = SemanticValidator()
    semantic_validator.validate(ast)
    if semantic_validator.errors:
        print("Semantic errors:")
        for error in semantic_validator.errors:
            print(error)
        return

    transformer = IRTransformer()
    ir = transformer.transform(ast)
    if transformer.errors:
        print("IR transformation errors:")
        for error in transformer.errors:
            print(error)
        return

    print(f"DEBUG: Full IR structure: node {ir.node_type} with children {[c.node_type for c in ir.children]}")
    if ir.children:
        for child in ir.children:
            print(f"DEBUG: Child node {child.node_type} with children {[gc.node_type for gc in child.children]}")

    key_map = load_key_map("pylutus_key.json")
    haskell_code = generate_haskell_code(ir.children[0], key_map)

    print(haskell_code)
    with open("output_contract.hs", "w") as f:
        f.write(haskell_code)
    print("Compiled to output_contract.hs")

if __name__ == "__main__":
    main()

