# Pylutus Forge

**Pylutus Forge** is a Python-to-Plutus compiler designed to enable developers to write Cardano smart contracts using Python-like syntax. These contracts are compiled into Plutus (Haskell) code suitable for on-chain deployment on the Cardano blockchain.

---

## 📁 Directory Structure

```bash
pylutus_forge/
├── compiler/
│   ├── __init__.py
│   ├── ast_parser.py
│   ├── type_checker.py
│   ├── semantic_validator.py
│   └── utils.py
├── tests/
│   ├── easy_contract.pylutus
│   ├── payment_contract.pylutus
│   ├── complex_contract.pylutus
│   ├── invalid_contract.pylutus
│   ├── unreachable_contract.pylutus
│   └── invalid_payment.pylutus
├── pylutus_forge.py
├── pylutus_key.json
├── output_contract.hs
├── test_ast_parser_updated.py
├── test_semantic_validator.py
├── test_symbol_table.py
├── test_type_checker.py
├── test_utils.py
├── LICENSE
└── README.md
```

---

## 🚀 Overview

Pylutus Forge lowers the barrier to entry for Cardano dApp developers by allowing them to write smart contracts in a clean, Pythonic domain-specific language (DSL) called **Pylutus**.

The tool compiles `.pylutus` files into valid Plutus scripts using the following pipeline:

* **Parser**: Processes `.pylutus` files, stripping comments and parsing Python-like syntax (`if/else`, `return`, etc.).
* **Type Checker**: Ensures type safety (e.g., `ctx: ScriptContext`, `bool` returns).
* **Semantic Validator**: Detects invalid or non-deterministic logic (e.g., unreachable code).
* **Macro Engine**: Replaces custom Pylutus functions like `pylutus_sig(...)` and `pylutus_pay(...)` using `pylutus_key.json`.
* **Code Generator**: Outputs clean Haskell code with `PlutusTx` support and proper smart contract structure.
* **Validator Compiler**: Generates validators for signature and payment conditions with `mkValidator`.

---

## ✅ Phase 1 — Core Compiler (Complete)

* 🔍 **Parser**: Python-like syntax support (`def`, `if`, `return`).
* 🔧 **Macro Expansion**: Converts custom commands into valid Plutus primitives.
* ⚙️ **Haskell Code Generation**: Uses `traceIfFalse`, `mkValidator`, and correct PlutusTx types.
* 🔐 **Validator Logic**: Supports signature validation with `pylutus_sig`.
* 📄 **Output**: Writes `output_contract.hs`, ready for on-chain deployment.

---

## ✅ Phase 2 — Type System & Validation (Complete)

* 🧠 **Static Type Checker**: Ensures `ctx: ScriptContext` and `bool` return types, catching errors like `return 42`.
* 🔍 **Semantic Validator**: Detects unreachable code (e.g., `if True`) and invalid payment amounts (< 1 ADA).
* 🧾 **Symbol Table**: Tracks variable types and scopes for robust validation.
* 🛠️ **Enhanced CLI**: `pylutus_forge.py` orchestrates parsing, type checking, semantic validation, and compilation with clear error reporting.
* 💸 **Payment Logic**: Implements `pylutus_pay` for transaction output validations (e.g., payments to specific addresses).

---

### ✅ Example Usage

**Source** (`tests/complex_contract.pylutus`):

```python
def validator(ctx: ScriptContext) -> bool:
    if pylutus_sig("abc123"):
        pylutus_pay("def456", 2000000)
        return True
    else:
        return False
```

**Compile**:

```bash
python3 pylutus_forge.py tests/complex_contract.pylutus
```

**Output** (`output_contract.hs`):

```haskell
-- Auto-generated by Pylutus Forge
{-# INLINABLE mkValidator #-}
import PlutusTx.Prelude
import Plutus.V1.Ledger.Api

mkValidator :: ScriptContext -> Bool
mkValidator ctx =
    if txSignedBy ctx (PubKeyHash "abc123") then
        traceIfFalse "Valid" (
            traceIfFalse "Payment failed" (checkPayment ctx (PubKeyHash "def456") 2000000)
            && traceIfFalse "Return" True
        )
    else
        traceIfFalse "Invalid" False

checkPayment :: ScriptContext -> PubKeyHash -> Integer -> Bool
checkPayment ctx pkh amount =
    any (\o -> txOutValue o == lovelaceValueOf amount && txOutAddress o == pubKeyHashAddress pkh)
        (txInfoOutputs $ scriptContextTxInfo ctx)
```

This generates a Plutus validator that checks for a signature from `abc123` and a payment of 2 ADA to `def456`.

---

## 🚧 Phase 3 — Future Roadmap

* 🧱 **Intermediate Representation (IR)**: Robust Haskell code generation via a typed IR layer.
* 🔄 **Full PlutusTx Type Mapping**: Better handling of Plutus types for complex contracts.
* 🧰 **Code Templates**: Include ready-made templates for validators, scripts, redeemers, etc.
* 🧠 **IDE Tooling**: VS Code plugin with syntax highlighting, hints, and code completion.

---

## 📦 How to Use

Write your smart contract in the `tests/` folder using `.pylutus` syntax.

Example contract (`tests/payment_contract.pylutus`):

```python
def validator(ctx: ScriptContext) -> bool:
    pylutus_pay("abc123", 2000000)
    return True
```

Compile it:

```bash
python3 pylutus_forge.py tests/payment_contract.pylutus
```

Output will be generated in:

```bash
output_contract.hs
```

Test the compiler with provided test scripts:

```bash
python3 test_symbol_table.py
python3 test_ast_parser_updated.py
python3 test_type_checker.py
python3 test_semantic_validator.py
python3 test_utils.py
```

Deploy using Cardano tooling.

---

## 📝 License

This project is open-source and available under the MIT License.

---

## 📬 Contact

**Author**: tvenk
**GitHub**: [tvenk](https://github.com/tvenk)
**LinkedIn**: [tbnv](https://www.linkedin.com/in/tbnv)

---
